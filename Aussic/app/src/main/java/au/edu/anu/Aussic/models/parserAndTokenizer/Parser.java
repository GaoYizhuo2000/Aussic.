package au.edu.anu.Aussic.models.parserAndTokenizer;

import java.util.*;

/**
 * Learn from the code of lab6
 *
 * The `Parser` class is responsible for parsing a sequence of tokens generated by a `Tokenizer`.
 * It extracts searching terms from the token stream and organizes them into a map.
 *
 * The grammar for the search terms is defined as follows:
 *      <Exp> = <term>| <term>;<Exp>
 *      <Term> = \a<Factor> | \n<Factor> | \g<Factor> | \r<Factor>
 *      <Factor> = String
 * eg: \a Troye; \nStrawberries and cigarettes
 *
 * - `<Exp>` can be a single `<Term>` or a sequence of `<Term>` separated by semicolons.
 * - `<Term>` consists of a prefix character (`\a`, `\n`, `\g`, or `\r`) followed by a `<Factor>`.
 * - `<Factor>` is a string.
 *
 * Example usage:
 * ```
 * Parser parser = new Parser(tokenizer);
 * Map<String, String> searchingTerms = parser.Parse();
 * ```
 *
 * The resulting `searchingTerms` map will contain key-value pairs where keys represent the type of search term
 * (e.g., "artistName", "name", "genre", "releaseDate", "user", or "undefinedTerm"), and values represent the
 * corresponding search term values extracted from the token stream.
 *
 * @author u7581818, Oscar Wei
 * @author u7552399, Yizhuo Gao
 * @author u7516507, Evan Cheung
 */


public class Parser {
    private Tokenizer tokenizer;
    public Parser(Tokenizer tokenizer) {
        this.tokenizer = tokenizer;
    }

    /**
     * Parses the token stream and extracts searching terms into a map.
     *
     * @return A `Map` containing extracted searching terms organized by their types.
     * @author: Oscar Wei
     */
    public Map<String, String> Parse() {
        Map<String, String> searchingTerms = new HashMap<>();
        while(tokenizer.hasNext()){
            if(tokenizer.current().getType() == Token.Type.ARTISTNAME){
                tokenizer.next();
                if(tokenizer.hasNext()){
                    String value = tokenizer.current().getToken();
                    searchingTerms.put("artistName", value);
                    tokenizer.next();
                }else{
                    break;
                }
            }

            else if(tokenizer.current().getType() == Token.Type.SONGNAME) {
                tokenizer.next();
                if(tokenizer.hasNext()){
                    String value = tokenizer.current().getToken();
                    searchingTerms.put("name", value);
                    tokenizer.next();
                }else{
                    break;
                }
            }

            else if(tokenizer.current().getType() == Token.Type.GENRE) {
                tokenizer.next();
                if(tokenizer.hasNext()){
                    String value = tokenizer.current().getToken();
                    searchingTerms.put("genre", value);
                    tokenizer.next();
                }else{
                    break;
                }
            }

            else if(tokenizer.current().getType() == Token.Type.RELEASEDATE) {
                tokenizer.next();
                if(tokenizer.hasNext()){
                    String value = tokenizer.current().getToken();
                    searchingTerms.put("releaseDate", value);
                    tokenizer.next();
                }else{
                    break;
                }
            }
            else if(tokenizer.current().getType() == Token.Type.USER){
                tokenizer.next();
                if(tokenizer.hasNext()){
                    String value = tokenizer.current().getToken();
                    searchingTerms.put("user", value);
                    tokenizer.next();
                }else{
                    break;
                }
            }
            else if(tokenizer.current().getType() == Token.Type.SEMICOLON){
                tokenizer.next();
                if(!tokenizer.hasNext()){break;}
            }
            else if(tokenizer.current().getType() == Token.Type.STRING) {
                searchingTerms.put("undefinedTerm", tokenizer.current().getToken());
                tokenizer.next();
            }
            else{
                break;
            }
        }
        return searchingTerms;
    }
}


